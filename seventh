"""
AI Service Layer for Face and Voice Recognition
Integrates face recognition and voice recognition models
"""

import os
import cv2
import numpy as np
import tensorflow as tf
import logging
from datetime import datetime
from PIL import Image
import io
import base64

logger = logging.getLogger(__name__)


class FaceRecognitionService:
    """Service for face recognition operations"""
    
    def __init__(self, model_path='models/face_recognition/saved_model.h5'):
        """Initialize face recognition service"""
        self.model_path = model_path
        self.model = None
        self.class_list = ['Alfred Enoch', 'Harry Potter', 'Hermione', 'Menna', 'Ron Weasley', 'Sama']
        self.input_size = (224, 224)
        
        # Load model
        self.load_model()
    
    def load_model(self):
        """Load the face recognition model"""
        try:
            if os.path.exists(self.model_path):
                self.model = tf.keras.models.load_model(
                    self.model_path,
                    custom_objects=None,
                    compile=True
                )
                logger.info(f"Face recognition model loaded from {self.model_path}")
            else:
                logger.warning(f"Model file not found: {self.model_path}")
                logger.warning("Face recognition will use placeholder predictions")
        except Exception as e:
            logger.error(f"Error loading face recognition model: {e}")
            self.model = None
    
    def preprocess_image(self, image):
        """Preprocess image for model prediction"""
        try:
            # Resize to model input size
            image_resized = cv2.resize(image, self.input_size)
            
            # Normalize pixel values (0-1)
            image_normalized = image_resized.astype('float32') / 255.0
            
            # Expand dimensions for batch processing
            img_array = np.expand_dims(image_normalized, axis=0)
            
            return img_array
        
        except Exception as e:
            logger.error(f"Error preprocessing image: {e}")
            raise
    
    def predict(self, image):
        """Make prediction on face image"""
        start_time = datetime.now()
        
        try:
            # Preprocess image
            img_array = self.preprocess_image(image)
            
            if self.model is not None:
                # Make prediction
                predictions = self.model.predict(img_array, verbose=0)
                
                # Get top prediction
                predict_index = np.argmax(predictions[0])
                primary_confidence = float(predictions[0][predict_index])
                predicted_class = self.class_list[predict_index]
                
                # Get second best for confidence delta
                predictions_sorted = np.sort(predictions[0])[::-1]
                secondary_confidence = float(predictions_sorted[1]) if len(predictions_sorted) > 1 else 0.0
                confidence_delta = primary_confidence - secondary_confidence
                
            else:
                # Placeholder prediction if model not loaded
                predicted_class = "Unknown"
                primary_confidence = 0.5
                secondary_confidence = 0.3
                confidence_delta = 0.2
            
            # Calculate processing time
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            
            result = {
                'predicted_identity': predicted_class,
                'primary_confidence': primary_confidence,
                'secondary_confidence': secondary_confidence,
                'confidence_delta': confidence_delta,
                'processing_time_ms': int(processing_time),
                'model_version': 'v1.0',
                'timestamp': datetime.now().isoformat()
            }
            
            logger.info(
                f"Face prediction: {predicted_class} "
                f"(confidence: {primary_confidence:.2%}, time: {processing_time:.0f}ms)"
            )
            
            return result
        
        except Exception as e:
            logger.error(f"Error making face prediction: {e}")
            raise
    
    def detect_face(self, image):
        """Detect if image contains a face"""
        try:
            # Use OpenCV's Haar Cascade for face detection
            face_cascade = cv2.CascadeClassifier(
                cv2.data.haarcascades + 'haarcascade_frontalface_default.xml'
            )
            
            # Convert to grayscale
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            
            # Detect faces
            faces = face_cascade.detectMultiScale(
                gray,
                scaleFactor=1.1,
                minNeighbors=5,
                minSize=(30, 30)
            )
            
            return len(faces) > 0, len(faces)
        
        except Exception as e:
            logger.error(f"Error detecting face: {e}")
            return False, 0
    
    def extract_face_encoding(self, image):
        """Extract face encoding/embedding for matching"""
        try:
            # This would use a proper face encoding library like face_recognition
            # For now, return a placeholder
            
            # In production, use:
            # import face_recognition
            # encodings = face_recognition.face_encodings(image)
            # return encodings[0] if encodings else None
            
            # Placeholder: return image hash
            img_resized = cv2.resize(image, (64, 64))
            encoding = img_resized.flatten().tolist()
            
            return encoding
        
        except Exception as e:
            logger.error(f"Error extracting face encoding: {e}")
            return None
    
    def calculate_image_quality(self, image):
        """Calculate image quality score"""
        try:
            # Convert to grayscale
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            
            # Calculate sharpness using Laplacian variance
            laplacian_var = cv2.Laplacian(gray, cv2.CV_64F).var()
            
            # Normalize to 0-1 scale (higher is better)
            quality_score = min(laplacian_var / 1000.0, 1.0)
            
            return quality_score
        
        except Exception as e:
            logger.error(f"Error calculating image quality: {e}")
            return 0.5
    
    def calculate_false_positive_risk(self, prediction_result):
        """Calculate false positive risk score"""
        try:
            risk_factors = []
            risk_score = 0.0
            
            # Low confidence
            if prediction_result['primary_confidence'] < 0.7:
                risk_factors.append('low_confidence')
                risk_score += 0.3
            
            # Small confidence delta (close second match)
            if prediction_result['confidence_delta'] < 0.2:
                risk_factors.append('small_confidence_delta')
                risk_score += 0.3
            
            # Unknown identity
            if prediction_result['predicted_identity'] == 'Unknown':
                risk_factors.append('unknown_identity')
                risk_score += 0.4
            
            # Cap at 1.0
            risk_score = min(risk_score, 1.0)
            
            return {
                'risk_score': risk_score,
                'risk_factors': risk_factors
            }
        
        except Exception as e:
            logger.error(f"Error calculating risk score: {e}")
            return {'risk_score': 0.5, 'risk_factors': ['error_calculating']}


class VoiceRecognitionService:
    """Service for voice recognition operations"""
    
    def __init__(self, model_path='models/voice_recognition/voice_model.h5'):
        """Initialize voice recognition service"""
        self.model_path = model_path
        self.model = None
        
        # Load model if available
        self.load_model()
    
    def load_model(self):
        """Load the voice recognition model"""
        try:
            if os.path.exists(self.model_path):
                self.model = tf.keras.models.load_model(
                    self.model_path,
                    custom_objects=None,
                    compile=True
                )
                logger.info(f"Voice recognition model loaded from {self.model_path}")
            else:
                logger.warning(f"Voice model file not found: {self.model_path}")
                logger.warning("Voice recognition will use placeholder predictions")
        except Exception as e:
            logger.error(f"Error loading voice recognition model: {e}")
            self.model = None
    
    def preprocess_audio(self, audio_path):
        """Preprocess audio file for prediction"""
        try:
            import librosa
            
            # Load audio file
            audio, sample_rate = librosa.load(audio_path, sr=16000)
            
            # Extract MFCC features
            mfccs = librosa.feature.mfcc(y=audio, sr=sample_rate, n_mfcc=13)
            
            # Normalize
            mfccs_normalized = (mfccs - np.mean(mfccs)) / np.std(mfccs)
            
            return mfccs_normalized
        
        except Exception as e:
            logger.error(f"Error preprocessing audio: {e}")
            raise
    
    def predict(self, audio_path):
        """Make prediction on voice audio"""
        start_time = datetime.now()
        
        try:
            if self.model is not None:
                # Preprocess audio
                features = self.preprocess_audio(audio_path)
                
                # Make prediction
                # This is placeholder - actual implementation depends on model architecture
                primary_confidence = 0.75
                predicted_identity = "Speaker_1"
            else:
                # Placeholder prediction
                primary_confidence = 0.6
                predicted_identity = "Unknown"
            
            # Calculate processing time
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            
            result = {
                'predicted_identity': predicted_identity,
                'primary_confidence': primary_confidence,
                'processing_time_ms': int(processing_time),
                'model_version': 'v1.0',
                'timestamp': datetime.now().isoformat()
            }
            
            logger.info(
                f"Voice prediction: {predicted_identity} "
                f"(confidence: {primary_confidence:.2%}, time: {processing_time:.0f}ms)"
            )
            
            return result
        
        except Exception as e:
            logger.error(f"Error making voice prediction: {e}")
            raise
    
    def calculate_audio_quality(self, audio_path):
        """Calculate audio quality score"""
        try:
            import librosa
            
            # Load audio
            audio, sr = librosa.load(audio_path, sr=16000)
            
            # Calculate SNR (Signal-to-Noise Ratio) approximation
            rms = librosa.feature.rms(y=audio)[0]
            quality_score = min(np.mean(rms) * 10, 1.0)
            
            return quality_score
        
        except Exception as e:
            logger.error(f"Error calculating audio quality: {e}")
            return 0.5


class AIMatchingService:
    """Service for matching reports using AI"""
    
    def __init__(self):
        """Initialize matching service"""
        self.face_service = FaceRecognitionService()
        self.voice_service = VoiceRecognitionService()
    
    def process_image(self, image_data, report_id):
        """Process image and return AI metrics"""
        try:
            # Decode base64 image
            if isinstance(image_data, str) and image_data.startswith('data:image'):
                image_data = image_data.split(',')[1]
            
            img_bytes = base64.b64decode(image_data)
            img = Image.open(io.BytesIO(img_bytes))
            img_cv = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
            
            # Detect face
            has_face, face_count = self.face_service.detect_face(img_cv)
            
            if not has_face:
                logger.warning(f"No face detected in image for report {report_id}")
                return {
                    'success': False,
                    'message': 'No face detected in image'
                }
            
            # Make prediction
            prediction = self.face_service.predict(img_cv)
            
            # Calculate image quality
            quality_score = self.face_service.calculate_image_quality(img_cv)
            
            # Calculate risk score
            risk_info = self.face_service.calculate_false_positive_risk(prediction)
            
            # Extract face encoding
            face_encoding = self.face_service.extract_face_encoding(img_cv)
            
            return {
                'success': True,
                'face_detected': True,
                'face_count': face_count,
                'prediction': prediction,
                'image_quality_score': quality_score,
                'risk_score': risk_info['risk_score'],
                'risk_factors': risk_info['risk_factors'],
                'face_encoding': face_encoding
            }
        
        except Exception as e:
            logger.error(f"Error processing image: {e}")
            return {
                'success': False,
                'message': str(e)
            }
    
    def find_matches(self, target_encoding, confidence_threshold=0.70):
        """Find matching reports based on face encoding"""
        from app.models.models import MissingReport, FileAttachment, ReportStatus
        
        try:
            matches = []
            
            # Query all active reports with face encodings
            reports = MissingReport.query.filter_by(
                status=ReportStatus.ACTIVE
            ).all()
            
            for report in reports:
                # Get face attachments
                face_attachments = FileAttachment.query.filter_by(
                    report_id=report.id,
                    file_type='photo',
                    is_processed=True
                ).all()
                
                for attachment in face_attachments:
                    if attachment.face_encoding:
                        # Calculate similarity
                        # In production, use proper face comparison
                        # For now, use placeholder similarity
                        similarity = 0.85  # Placeholder
                        
                        if similarity >= confidence_threshold:
                            matches.append({
                                'report_id': report.id,
                                'confidence': similarity,
                                'match_type': 'face',
                                'attachment_id': attachment.id
                            })
            
            logger.info(f"Found {len(matches)} potential matches")
            return matches
        
        except Exception as e:
            logger.error(f"Error finding matches: {e}")
            return []
    
    def check_duplicate_match(self, report_id, predicted_identity, confidence):
        """Check if similar match already exists"""
        from app.models.models import MatchResult
        from datetime import timedelta
        
        try:
            # Look for recent matches with same identity
            recent_cutoff = datetime.utcnow() - timedelta(hours=24)
            
            existing = MatchResult.query.filter(
                MatchResult.report_id == report_id,
                MatchResult.matched_identity == predicted_identity,
                MatchResult.created_at >= recent_cutoff
            ).first()
            
            return existing is not None
        
        except Exception as e:
            logger.error(f"Error checking duplicate: {e}")
            return False


# Global service instances
_face_service = None
_voice_service = None
_matching_service = None


def get_face_service():
    """Get or create face recognition service instance"""
    global _face_service
    if _face_service is None:
        _face_service = FaceRecognitionService()
    return _face_service


def get_voice_service():
    """Get or create voice recognition service instance"""
    global _voice_service
    if _voice_service is None:
        _voice_service = VoiceRecognitionService()
    return _voice_service


def get_matching_service():
    """Get or create matching service instance"""
    global _matching_service
    if _matching_service is None:
        _matching_service = AIMatchingService()
    return _matching_service
