"""
Logging Configuration for Returno Face Recognition System
Implements comprehensive logging with file rotation and formatting
"""

import os
import logging
from logging.handlers import RotatingFileHandler
from datetime import datetime
import colorlog


def setup_logging(app):
    """Setup application logging with file and console handlers"""
    
    # Create logs directory if it doesn't exist
    os.makedirs('logs', exist_ok=True)
    
    # Get log level from config
    log_level = getattr(logging, app.config.get('LOG_LEVEL', 'INFO'))
    
    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    
    # Remove existing handlers
    root_logger.handlers = []
    
    # File Handler with rotation
    file_handler = RotatingFileHandler(
        app.config.get('LOG_FILE', 'logs/returno.log'),
        maxBytes=app.config.get('LOG_MAX_BYTES', 10 * 1024 * 1024),  # 10MB
        backupCount=app.config.get('LOG_BACKUP_COUNT', 5)
    )
    file_handler.setLevel(log_level)
    
    # File formatter
    file_formatter = logging.Formatter(
        '[%(asctime)s] %(levelname)s in %(module)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    file_handler.setFormatter(file_formatter)
    
    # Console Handler with colors
    console_handler = colorlog.StreamHandler()
    console_handler.setLevel(log_level)
    
    # Console formatter with colors
    console_formatter = colorlog.ColoredFormatter(
        '%(log_color)s[%(asctime)s] %(levelname)s%(reset)s - %(message)s',
        datefmt='%H:%M:%S',
        log_colors={
            'DEBUG': 'cyan',
            'INFO': 'green',
            'WARNING': 'yellow',
            'ERROR': 'red',
            'CRITICAL': 'red,bg_white',
        }
    )
    console_handler.setFormatter(console_formatter)
    
    # Add handlers
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)
    
    # Setup Flask app logger
    app.logger.setLevel(log_level)
    app.logger.addHandler(file_handler)
    app.logger.addHandler(console_handler)
    
    # Log startup
    app.logger.info("=" * 70)
    app.logger.info(f"Returno Face Recognition System Started")
    app.logger.info(f"Environment: {app.config.get('ENV', 'development')}")
    app.logger.info(f"Debug Mode: {app.config.get('DEBUG', False)}")
    app.logger.info(f"Log Level: {logging.getLevelName(log_level)}")
    app.logger.info("=" * 70)
    
    # Setup audit logger
    setup_audit_logger(app)
    
    # Setup security logger
    setup_security_logger(app)
    
    return app.logger


def setup_audit_logger(app):
    """Setup dedicated audit logger"""
    audit_logger = logging.getLogger('audit')
    audit_logger.setLevel(logging.INFO)
    
    # Audit log file handler
    audit_handler = RotatingFileHandler(
        'logs/audit.log',
        maxBytes=10 * 1024 * 1024,
        backupCount=10
    )
    
    audit_formatter = logging.Formatter(
        '[%(asctime)s] AUDIT: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    audit_handler.setFormatter(audit_formatter)
    
    audit_logger.addHandler(audit_handler)
    
    app.logger.info("Audit logger configured")


def setup_security_logger(app):
    """Setup dedicated security logger"""
    security_logger = logging.getLogger('security')
    security_logger.setLevel(logging.WARNING)
    
    # Security log file handler
    security_handler = RotatingFileHandler(
        'logs/security.log',
        maxBytes=10 * 1024 * 1024,
        backupCount=10
    )
    
    security_formatter = logging.Formatter(
        '[%(asctime)s] SECURITY %(levelname)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    security_handler.setFormatter(security_formatter)
    
    security_logger.addHandler(security_handler)
    
    app.logger.info("Security logger configured")


def log_audit(action, user_id=None, details=None, ip_address=None, success=True):
    """Log audit event"""
    audit_logger = logging.getLogger('audit')
    
    message_parts = [f"Action: {action}"]
    
    if user_id:
        message_parts.append(f"User: {user_id}")
    
    if ip_address:
        message_parts.append(f"IP: {ip_address}")
    
    if details:
        message_parts.append(f"Details: {details}")
    
    message_parts.append(f"Success: {success}")
    
    audit_logger.info(" | ".join(message_parts))


def log_security(level, event, user_id=None, ip_address=None, details=None):
    """Log security event"""
    security_logger = logging.getLogger('security')
    
    message_parts = [f"Event: {event}"]
    
    if user_id:
        message_parts.append(f"User: {user_id}")
    
    if ip_address:
        message_parts.append(f"IP: {ip_address}")
    
    if details:
        message_parts.append(f"Details: {details}")
    
    message = " | ".join(message_parts)
    
    if level == 'warning':
        security_logger.warning(message)
    elif level == 'error':
        security_logger.error(message)
    elif level == 'critical':
        security_logger.critical(message)
    else:
        security_logger.info(message)


class RequestLogger:
    """Middleware for logging HTTP requests"""
    
    def __init__(self, app=None):
        self.app = app
        if app is not None:
            self.init_app(app)
    
    def init_app(self, app):
        """Initialize request logging"""
        
        @app.before_request
        def log_request():
            """Log incoming requests"""
            from flask import request
            
            # Skip logging for static files
            if request.path.startswith('/static'):
                return
            
            app.logger.debug(
                f"Request: {request.method} {request.path} | "
                f"IP: {request.remote_addr} | "
                f"Agent: {request.user_agent.string[:100]}"
            )
        
        @app.after_request
        def log_response(response):
            """Log responses"""
            from flask import request
            
            # Skip logging for static files
            if request.path.startswith('/static'):
                return response
            
            app.logger.debug(
                f"Response: {response.status_code} | "
                f"{request.method} {request.path}"
            )
            
            return response


class AILogger:
    """Specialized logger for AI operations"""
    
    @staticmethod
    def log_prediction(model_name, input_type, confidence, processing_time):
        """Log AI prediction"""
        logger = logging.getLogger('ai')
        logger.info(
            f"Prediction | Model: {model_name} | "
            f"Type: {input_type} | "
            f"Confidence: {confidence:.4f} | "
            f"Time: {processing_time}ms"
        )
    
    @staticmethod
    def log_match(report_id, confidence, match_type):
        """Log match detection"""
        logger = logging.getLogger('ai')
        logger.info(
            f"Match Detected | Report: {report_id} | "
            f"Type: {match_type} | "
            f"Confidence: {confidence:.4f}"
        )
    
    @staticmethod
    def log_false_positive(match_id, reason):
        """Log false positive"""
        logger = logging.getLogger('ai')
        logger.warning(
            f"False Positive | Match: {match_id} | "
            f"Reason: {reason}"
        )


def log_exception(exception, context=None):
    """Log exception with context"""
    logger = logging.getLogger()
    
    message = f"Exception: {type(exception).__name__}: {str(exception)}"
    
    if context:
        message += f" | Context: {context}"
    
    logger.exception(message)


def get_log_stats():
    """Get logging statistics"""
    stats = {
        'log_files': [],
        'total_size_mb': 0
    }
    
    try:
        log_dir = 'logs'
        if os.path.exists(log_dir):
            for filename in os.listdir(log_dir):
                filepath = os.path.join(log_dir, filename)
                if os.path.isfile(filepath):
                    size_mb = os.path.getsize(filepath) / (1024 * 1024)
                    stats['log_files'].append({
                        'name': filename,
                        'size_mb': round(size_mb, 2),
                        'modified': datetime.fromtimestamp(
                            os.path.getmtime(filepath)
                        ).isoformat()
                    })
                    stats['total_size_mb'] += size_mb
            
            stats['total_size_mb'] = round(stats['total_size_mb'], 2)
    
    except Exception as e:
        logging.error(f"Error getting log stats: {e}")
    
    return stats
